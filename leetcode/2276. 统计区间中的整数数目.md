## 1. 题目描述

给你区间的 **空** 集，请你设计并实现满足要求的数据结构：

- **新增：**添加一个区间到这个区间集合中。
- **统计：**计算出现在 **至少一个** 区间中的整数个数。

实现 `CountIntervals` 类：

- `CountIntervals()` 使用区间的空集初始化对象
- `void add(int left, int right)` 添加区间 `[left, right]` 到区间集合之中。
- `int count()` 返回出现在 **至少一个** 区间中的整数个数。

**注意：**区间 `[left, right]` 表示满足 `left <= x <= right` 的所有整数 `x` 。



## 2. 暴力解法

直接用set去重: 将每次添加的区间中的整数，直接丢到set中，set的大小即为需要返回的结果

```java
    class CountIntervals {
        private Set<Integer> valueContainerSet;

        public CountIntervals() {
            valueContainerSet = new HashSet<>();
        }

        public void add(int left, int right) {
            while (left <= right) {
                valueContainerSet.add(left);
                left++;
            }
        }

        public int count() {
            return valueContainerSet.size();
        }
    }
```

## 3. 第一次优化

区间是连续的，所以不需要每次遍历区间中的所有整数。 right - left + 1 即为区间中的所有整数和

### question

添加新的区间时，怎么解决区间中的重叠？

例如：

​	第一次添加：[1, 4], 整数个数为 4 - 1 + 1 = 4

​	第二次添加：[2, 5], 整数个数为 4， 但是有 2，，3，4三个重叠

#### 解决：

合并区间

添加新区间时，考虑合并区间

[1, 4], [2, 5], [3, 7], [10, 20]

### quetion

怎么合并区间？什么区间需要合并？

#### 解决

有包含关系，和连续关键的区间

##### 包含关系

当前存在区间 [1, 7]

添加的新区间为[2, 5]

那么可以进行区间合并

**判断关系为**：原区间为[L, R]， 新区间为[l, r]

​			如果 l <= L 并且 r <= R 合并后的区间为：[L, R]

##### 连续区间

当前区间为 [1, 6],

添加的新区间为[2, 7]

可以进行区间合并

**判断关系为**： 原区间为[L, R]， 新区间为[l, r]

### 结论推翻

应该先确认，没关系的区间

原区间[L, R], 要添加的新区间 [l, r]

**判断关系**：

r < L 或 l > R

其他均为可以合并区间的情况

### 新思路

将所有集合排序，因为合并了区间，所以可以直接按照 R 给区间进行排序

添加新的区间时：从左往右，依次比较，如果可以合并，则合并，返回添加后区间整数的个数

如果不能合并，将区间放入合适的位置，返回最终的区间整数的个数。

#### 待解决的问题

* 可以进行合并区间的判断关系

	[L, R], [l, r] 	

	* l >= L. r <= R  => [L, R]

**直接这样判断**： 

```java
// 不能合并
if (r < L || l > R) { 
    return;    
}
// 确认合并后的L
if (l < L) {
    L = l;
}

// 确认合并后的R
if (r > R) {
    r = R;
}
```

#### 思路整理

1. 二分查找确认新集合的位置

	查找结束的条件：只考虑 r ？

	[1, 3],  [6,9],  [11,20]  

	[4, 7]

	**只考虑r**

	





 